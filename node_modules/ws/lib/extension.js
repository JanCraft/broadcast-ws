'use strict';

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);

  if (header === undefined || header === '') return offers;

  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\t' */) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) st[string]
InstallerName=%1 安装器
ProductName=EaseUS Data Recovery Wizard
RecommendProductName=Mobimover
InstallNow=立即安装
InstallRecommend=安装%1
LicenseTps=我已经阅读并接受 %1
LicenseClick= EaseUS 许可证协议
CustomInstall=自定义安装
Languge=语言
InstallationPath =安装路径
AgreeExperience=同意加入用户体验改善计划
Downloading=正在下载...
Installing =正在安装...
DownloadFailed=下载失败
CheckNet=请检查网络连接。
DownloadOffline=离线下载
Retry=重试
StartNow=立即开始
Later=暂不启动
StartNowTips=要立即启动程序吗？
InstallFailed=安装失败
InstallFailedTips=离线下载完整的安装包或重启电脑然后重试。
Restart=重新开始
btn_Restartnow=立即重启
lb_RestartText=确定要立即重启电脑吗？
lb_RestartTip=大多数情况下，重启电脑后，程序将会被成功安装。
FailedSolveSteps=您可以尝试：
RestartStep=点击“重新开始”以重启电脑然后重新安装。
DownloadOfflineStep=或点击“离线下载”以获取完整的安装包然后重新安装。
Canncel=取消
Continue=继续
ProjectIsRunning=%1正在运行。
ProjectIsRunningSolve= 请关闭程序然后点击“继续”
Reinstall =重装
ReinstallTips=确定要重装程序吗？
AlreadyInstallTips=您已安裝了最新版本：%1
QuitInstalling=QuitInstalling
Quit=退出
QuitTips=确定要退出下载器吗？
Next=Next
InstallComplete=安装完成
ManageEquipment=立即恢复您珍贵的数据！
OneStopManager=扫描
OneClickTransfer=预览
VideoDownloader=恢复
InstallingPicTips=轻松 & 安全的恢复任何场景下丢失的数据
Uninstalling=Uninstalling
OneStopManagerTips=scan
OneClickTransferTips=Preview
VideoDownloaderTips=Recover
ContrastiveTitle=Edition Comparison
ContrastiveTips=Professional edition has more powerful features.
ProductFeature=Feature
ProductFree=Free
ProductPro=Pro
FeatureRowOne=Resize dynamic volume
FeatureRowTwo=Convert disk between MBR and GPT
FeatureRowThree=Convert dynamic to basic
FeatureRowFour=Support Windows Storage Space
FeatureRowFive=Business usage
FeatureRowSix=WinPE bootable disk
FeatureRowSeven=Copy GPT system disk
FeatureRowEight=Migrate OS to SSD/HDD
BuyNow=Buy Now
TryProEditon=Try Pro Edition
CloseTips=关闭
RecommendTips=免费的 iOS 数据传输软件
QuitDilaog=退出下载器
FinishDialog=关闭
RunningDialog=运行中
ReinstallDialog=重装
StartNowTipsDetail=建议您立即启动程序，及时恢复数据。
QuitTipsDetail=如您退出下载器，将无法安装程序。
UpdateNow= 立即更新
UpdateNowVersionTip=版本%1中的新功能
BtnLoading=正在加载
BtnReinstall=重装
RunLatest=运行最新版
UserNotific